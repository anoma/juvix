module MiniTicTacToe;

open import Stdlib.Data.Nat.Ord;
open import Stdlib.Prelude;

--------------------------------------------------------------------------------
-- Render Utils
--------------------------------------------------------------------------------

infixr 5 ++str;
axiom ++str : String → String → String;
compile ++str {
  c ↦ "concat";
};

concat : List String → String;
concat ≔ foldl (++str) "";

surround : String → List String → List String;
surround x xs ≔ (x ∷ intersperse x xs) ++ (x ∷ nil);

intercalate : String → List String → String;
intercalate sep xs ≔ concat (intersperse sep xs);

unlines : List String → String;
unlines ≔ intercalate "\n";

--------------------------------------------------------------------------------
-- Symbol
--------------------------------------------------------------------------------

inductive Symbol {
  O : Symbol;
  X : Symbol;
};

==Symbol : Symbol → Symbol → Bool;
==Symbol O O ≔ true;
==Symbol X X ≔ true;
==Symbol _ _ ≔ false;

switch : Symbol → Symbol;
switch O ≔ X;
switch X ≔ O;

showSymbol : Symbol → String;
showSymbol O ≔ "O";
showSymbol X ≔ "X";

--------------------------------------------------------------------------------
-- Square
--------------------------------------------------------------------------------

inductive Square {
  empty : ℕ → Square;
  occupied : Symbol → Square;
};

==Square : Square → Square → Bool;
==Square (empty m) (empty n) ≔ m == n;
==Square (occupied s) (occupied t) ≔ ==Symbol s t;
==Square _ _ ≔ false;

showSquare : Square → String;
showSquare (empty n) ≔ " " ++str natToStr n ++str " ";
showSquare (occupied s) ≔ " " ++str showSymbol s ++str " ";

--------------------------------------------------------------------------------
-- Board
--------------------------------------------------------------------------------

inductive Board {
  board : List (List Square) → Board;
};

possibleMoves : List Square → List ℕ;
possibleMoves nil ≔ nil;
possibleMoves ((empty n) ∷ xs) ≔ n ∷ possibleMoves xs;
possibleMoves (_ ∷ xs) ≔ possibleMoves xs;

full : List Square → Bool;
full (a ∷ b ∷ c ∷ nil) ≔ (==Square a b) && (==Square b c);

diagonals : List (List Square) → List (List Square);
diagonals ((a1 ∷ _ ∷ b1 ∷ nil) ∷ (_ ∷ c ∷ _ ∷ nil) ∷ (b2 ∷ _ ∷ a2 ∷ nil) ∷ nil) ≔ (a1 ∷ c ∷ a2 ∷ nil) ∷ (b1 ∷ c ∷ b2 ∷ nil) ∷ nil;

columns : List (List Square) → List (List Square);
columns ≔ transpose;

rows : List (List Square) → List (List Square);
rows ≔ id;

showRow : List Square → String;
showRow xs ≔ concat (surround "|" (map showSquare xs));

showBoard : Board → String;
showBoard (board squares) ≔ unlines (surround "+---+---+---+" (map showRow squares));

--------------------------------------------------------------------------------
-- Error
--------------------------------------------------------------------------------

inductive Error {
  noError : Error;
  continue : String → Error;
  terminate : String → Error;
};

--------------------------------------------------------------------------------
-- GameState
--------------------------------------------------------------------------------

inductive GameState {
  state : Board → Symbol → Error → GameState;
};

showGameState : GameState → String;
showGameState (state b _ _) ≔ showBoard b;

player : GameState → Symbol;
player (state _ p _) ≔ p;

beginState : GameState;
beginState ≔ state
     (board (map (map empty) ((one ∷ two ∷ three ∷ nil) ∷ (four ∷ five ∷ six ∷ nil) ∷ (seven ∷ eight ∷ nine ∷ nil) ∷ nil)))
     X
     noError;

won : GameState → Bool;
won (state (board squares) _ _) ≔ any full (diagonals squares ++ rows squares ++ columns squares);

draw : GameState → Bool;
draw (state (board squares) _ _) ≔ null (possibleMoves (flatten squares));

--------------------------------------------------------------------------------
-- Move
--------------------------------------------------------------------------------

replace : Symbol → ℕ → Square → Square;
replace player k (empty n) ≔ if (n Stdlib.Data.Nat.Ord.== k) (occupied player) (empty n);
replace _ _ s ≔ s;

checkState : GameState → GameState;
checkState (state b p e) ≔
  if (won (state b p e))
     (state b p (terminate ("Player " ++str (showSymbol (switch p)) ++str " wins!")))
     (if (draw (state b p e))
         (state b p (terminate "It's a draw!"))
         (state b p e));

playMove : Maybe ℕ → GameState → GameState;
playMove nothing (state b p _) ≔
    state b p (continue "\nInvalid number, try again\n");
playMove (just k) (state (board s) player e) ≔
    if (not (elem (==) k (possibleMoves (flatten s))))
        (state (board s) player (continue "\nThe square is already occupied, try again\n"))
        (checkState (state (board (map (map (replace player k)) s))
                           (switch player)
                           noError));

--------------------------------------------------------------------------------
-- IO Utils
--------------------------------------------------------------------------------

axiom readline : String;
compile readline {
  c ↦ "readline()";
};

axiom parsePositiveInt : String → ℕ;

compile parsePositiveInt {
  c ↦ "parsePositiveInt";
};

--------------------------------------------------------------------------------
-- IO
--------------------------------------------------------------------------------

validMove : ℕ → Maybe ℕ;
validMove n ≔ if ((n <= nine) && (n >= one)) (just n) nothing;

getMove : Maybe ℕ;
getMove ≔ validMove (parsePositiveInt (readline));

do : IO × GameState -> GameState;
do (_ , s) ≔ playMove getMove s;

prompt : GameState → String;
prompt x ≔ "\n" ++str (showGameState x) ++str "\nPlayer " ++str showSymbol (player x) ++str ": ";

terminating
run : (IO × GameState → GameState) → GameState → IO;
run _ (state b p (terminate msg)) ≔ putStrLn ("\n" ++str (showGameState (state b p noError)) ++str "\n" ++str msg);
run f (state b p (continue msg)) ≔ run f (f (putStr (msg ++str prompt (state b p noError)) , state b p noError));
run f x ≔ run f (f (putStr (prompt x) , x));

welcome : String;
welcome ≔ "MiniTicTacToe\n-------------\n\nType a number then ENTER to make a move";

main : IO;
main ≔ putStrLn welcome >> run do beginState;
end;
