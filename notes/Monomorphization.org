* Monomorphization
 Monomorphization refers to the process of converting polymorphic code to
 monomorphic code (no type variables) through static analysis.

 Example:
 #+begin_src minijuvix
 id : (A : Type) ‚Üí A ‚Üí A;
 id _ a ‚âî a;

 b : Bool;
 b ‚âî id Bool true;

 n : Nat;
 n ‚âî id Nat zero;
 #+end_src

 Is translated into:
 #+begin_src minijuvix
 id_Bool : Bool ‚Üí Bool;
 id_Bool a ‚âî a;

 id_Nat : Nat ‚Üí Nat;
 id_Nat a ‚âî a;
 #+end_src

* More examples
** Mutual recursion
#+begin_src minijuvix
inductive List (A : Type) {
  nil : List A;
  cons : A ‚Üí List A ‚Üí List A;
};

even : (A : Type) ‚Üí List A ‚Üí Bool;
even A nil ‚âî true ;
even A (cons _ xs) ‚âî not (odd A xs) ;

odd : (A : Type) ‚Üí List A ‚Üí Bool;
odd A nil ‚âî false ;
odd A (cons _ xs) ‚âî not (even A xs) ;

-- main ‚âî even Bool ..  odd Nat;
#+end_src

* Collection algorithm
 This section describes the algorithm to collect the list of all concrete
 functions and inductive definitions that need to be generated.

** Assumptions:
1. Type abstractions only appear at the leftmost part of a type signature.
2. All functions and constructors are fully type-applied: i.e. currying for
   types is not supported.
3. There is at least one function with a concrete type signature.
4. All axioms are monomorphic.
5. No module parameters.

** Definitions
1. *Application*. An application is an expression of the form =t‚ÇÅ t‚ÇÇ ‚Ä¶ t‚Çô= with n > 0.

2. *Sub application*. If =t‚ÇÅ t‚ÇÇ ‚Ä¶ t‚Çô= is an application then for every =0<i<n=
   =t‚ÇÅ t‚ÇÇ ‚Ä¶ t·µ¢= is a sub application.

Fix a minijuvix program =P=. Let =ùí≤= be the set of all applications that appear in =P=.
1. *Maximal application*. A maximal application is an application =A‚ààùí≤= such that
   for every =A'‚ààùí≤= we have that =A= is *not* a sub application of =A'=.

2. *Type application*. If
   1. =t a‚ÇÅ a‚ÇÇ ‚Ä¶ a‚Çô= is a maximal application; and
   1. =t= is either a function or an inductive type; and
   2. =a‚ÇÅ, ‚Ä¶, a‚Çò= are types; and
   3. =a‚Çò‚Çä‚ÇÅ= is not a type or =m = n=.
   Then =t a‚ÇÅ, ‚Ä¶, a‚Çò= is a type application.

3. *Concrete type*. A type is concrete if it involves no type variables.

4. *Concrete type application*. A type application =t a‚ÇÅ a‚ÇÇ ‚Ä¶ a‚Çô= if =a‚ÇÅ, a‚ÇÇ, ‚Ä¶,
   a‚Çô= are concrete types.

** Option 1
  Let =S‚ÇÄ= be the set of functions with a concrete type signature. Gather all
  type applications (both in the type and in the body) in each of the functions
  in =S‚ÇÄ=. Clearly the collected type applications are all concrete. We now have
  a stack =c‚ÇÅ, c‚ÇÇ, ‚Ä¶, c‚Çô= of concrete type applications.
  1. If the stack is empty, we are done.
  2. Otherwise pop =c‚ÇÅ= from the stack. It will be of the form =t a‚ÇÅ ‚Ä¶ a‚Çò=,
     where =t= is either an inductive or a function and =a‚ÇÅ, ‚Ä¶, a‚Çò= are
     concrete types.
  3. If the instantiation =t a‚ÇÅ ‚Ä¶ a‚Çò= has already been registered go to step 1.
     Otherwise continue to the next step.
  4. Register the instantiation =t a‚ÇÅ ‚Ä¶ a‚Çò=.
  5. If =t= is a function, then it has type variables =v‚ÇÅ, ‚Ä¶, v‚Çò=.
     Consider the substitution =œÉ = {v‚ÇÅ ‚Ü¶ a‚ÇÅ, ‚Ä¶, v‚Çò ‚Ü¶ a‚Çò}=.
     Consider the list of type applications in the body of =t=: =d‚ÇÅ, ‚Ä¶, d·µ£=.
     Add =œÉ(d‚ÇÅ), ‚Ä¶, œÉ(d·µ£)= to the stack and continue to step 1.
     It is easy to see that for any =i=, =œÉ(d·µ¢)= is a concrete type application.
  6. If =t= is an inductive type, let =d‚ÇÅ, ‚Ä¶, d·µ£= be the type applications that
     appear in the type of its constructors, then proceed as before.

*** Correctness
   It should be clear that the algorithm terminates and registers all
   instantiations of constructors and functions.

* Generation algorithm

 The input of this algorithm is the list of concrete type applications, name it
 =‚Ñí=, produced by the collection algorithm. Example:
 #+begin_example
 List String
 Pair Int Bool
 Maybe String
 Maybe Int
 if (Maybe String)
 if (Maybe Int)
 if (Pair Int Bool)
 #+end_example

** Name generation

Let =f √¢= be an arbitrary element of =‚Ñí=, where =√¢= is a list of concrete types.
- If =f= is a function, assign a fresh name to =f √¢=, call it =‚ãÜ(f √¢)=.
- If =f= is an inductive type, assign a fresh name to =f √¢=, call it
  =‚ãÜ(f √¢)=. Then, for each constructor =c·µ¢= of =f=, where =i= is the index of
  the constructor, assign a fresh name to it and call it =‚ãÜ·µ¢(f √¢)=.

** Function generation
Consider an arbitrary function =f= in the original program. Then consider the
list of concrete type applications involving =f=: =f √¢‚ÇÅ, ‚Ä¶, f √¢‚Çô=.
- If =n = 0=, then either:
  1. =f= has a concrete type signature, in that case we proceed as expected.
  2. =f= is never called from the functions with a concrete type. In this case we
     can safely ignore it.
- If =n > 1=. For each =√¢·µ¢= we proceed as follows in the next sections. Fix =m= to be
  the lenght of =√¢·µ¢= with =m > 0=.

*** Function name
 The name of the monomorphized function is =‚ãÜ(f √¢·µ¢)=.

*** Type signature
 Let =ùíÆ= be the type signature of =f=. Then =ùíÆ= has to be of the form =(A‚ÇÅ :
 Type) ‚Üí ‚Ä¶ ‚Üí (A‚Çò : Type) ‚Üí Œ†=, where =Œ†= is a type with no type abstractions.
 Now consider the substitution =œÉ = {A‚ÇÅ ‚Ü¶ √¢·µ¢[1], ‚Ä¶, A‚Çò ‚Ü¶ √¢·µ¢[m]}=. Since =√¢·µ¢= is
 a list of concrete types, it is clear that =œÉ(Œ†)= is a concrete type.
 Then proceed as described in [[Types]].

*** Function clause
 Let =ùíû= be a function clause of =f=. Let =p‚ÇÅ ‚Ä¶ p‚Çñ= with =k ‚â• m= be the list of
 patterns in =ùíû=. Clearly the first =m= patterns must be either variables or
 wildcards. Wlog assume that the first =m= patterns are all variables, namely
 =v‚ÇÅ, ‚Ä¶, v‚Çò=. Let =œÉ = {v‚ÇÅ ‚Ü¶ √¢·µ¢[1], ‚Ä¶, A‚Çò ‚Ü¶ √¢·µ¢[m]}= be a substitution. Let =e=
 be the body of =ùíû=, then clearly =œÉ(e)= has no type variables in it. Now, since
 each name id must be bound at most once, we need to generate new ones for the
 local variables bound in the patterns =p‚Çò‚Çä‚ÇÅ, ‚Ä¶, p‚Çñ=. Let =w‚ÇÅ, ‚Ä¶, w‚Çõ=
 be the variables bound in =p‚Çò‚Çä‚ÇÅ, ‚Ä¶, p‚Çñ=. Let =w'‚ÇÅ, ‚Ä¶, w'‚Çõ= be fresh variables.
 Then let =Œ¥ = {w‚ÇÅ ‚Ü¶ w'‚ÇÅ, ‚Ä¶, w‚Çõ ‚Ü¶ w'‚Çõ}=.

 Now let =ùíû'= have patterns =Œ¥(p‚Çò‚Çä‚ÇÅ), ‚Ä¶, Œ¥(p‚Çñ)= and let =e' ‚âî (œÉ ‚à™ Œ¥)(e)=. It
 should be clear that =e'= has no type variables in it and that all local
 variable references in =e'= are among =w'‚ÇÅ, ‚Ä¶, w'‚Çõ=. Note that =e'= is not yet
 monomorphized. Proceed to the next step to achieve that.

*** Expressions
 The input is an expression =e= that has no type variables in it. The goal is to
 replace the concrete type applications by the corresponding monomorphized
 expression.

 The only interesting case is when we find an application. Consider the unfolded
 view of the application: =f a‚ÇÅ ‚Ä¶ a‚Çò=. Then, if =f= is either a constructor, or
 a function, let =A‚ÇÅ, ‚Ä¶, A‚Çñ= with =k ‚â§ m= be the list of type parameters of =f=.
 - If =f= is a function and =f a‚ÇÅ ‚Ä¶ a‚Çñ ‚àâ ‚Ñí= then recurse normally, otherwise,
   let =√¢ ‚âî a‚ÇÅ ‚Ä¶ a‚Çñ= and replace the original expression =f a‚ÇÅ ‚Ä¶ a‚Çò=, by =‚ãÜ(f √¢)
   a‚Çñ‚Çä‚ÇÅ' ‚Ä¶ a‚Çò'= where =a‚Çñ‚Çä‚ÇÅ' ‚Ä¶ a‚Çò'= are the monomorphization of =a‚Çñ‚Çä‚ÇÅ ‚Ä¶ a‚Çò=
   respectively.
 - If =f= is a constructor, let =d= be its inductive type. Then check =d a‚ÇÅ ‚Ä¶ a‚Çñ
   ‚àà ‚Ñí=. Proceed analogously as before.

*** Types
The input is a type =t= that has no type variables in it. The goal is to
replace the concrete type applications by the corresponding monomorphized
type. Proceed analogously to the previous section.
