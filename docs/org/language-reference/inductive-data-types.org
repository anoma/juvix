* Inductive data types

The =inductive= keyword is reserved to declare simple inductive data types.
An inductive type needs a name and it may have parameters or functions called data constructors used to build terms of their corresponding inductive type. The simplest inductive type is the empty type defined as follows:

#+begin_example
inductive Empty {};
#+end_example

In the following example, we declare the inductive type =Nat=, the unary representation of natural numbers. This type comes with two data constructors, namely =zero= and =suc=. For example, the number one is represented by `suc zero`, two by `suc (suc zero)`, etc.

#+begin_example
inductive Nat {
    zero : Nat;
    suc : Nat → Nat;
};
#+end_example

The way to use inductive types is by declaring functions by pattern matching.
Let us define, for example, the function for adding two natural numbers. 

#+begin_src text
inifl 6 +;
+ : Nat → Nat → Nat;
+ zero b ≔ b;
+ (suc a) b ≔ suc (a + b);
#+end_src

As mentioned ealier, an inductive type may have type parameters. The canonical example is the polymorphic type =List=. The type =List= is the inductive type that takes as parameter the type of the elements in the list. This type has two data constructors. A constructor to build the empty list, that is the base case, and another constructor to enlarge the list, we usually called it =cons=.
One possibly definition for this type is the following type taken from the Juvix standard library:

#+begin_example
infixr 5 ∷;
inductive List (A : Type) {
  nil : List A;
  ∷ : A → List A → List A;
};

elem : {A : Type} → (A → A → Bool) → A → List A → Bool;
elem _ _ nil ≔ false;
elem eq s (x ∷ xs) ≔ eq s x || elem eq s xs;
#+end_example

To see more examples of inductive types and how to use them, please check out
[[https://anoma.github.io/juvix-stdlib/][the Juvix standard library]]