* Inductive data types

The =inductive= keyword is reserved for declaring simple inductive data types.
An inductive type declaration needs a name for its type and functions called data constructors used to build its terms. As shown later, one can also provide
type parameters to widen the family of inductive types one can define in =Juvix=.

The simplest inductive type is the empty type defined as follows:

#+begin_example
inductive Empty {};
#+end_example

In the following example, we declare the inductive type =Nat=, the unary representation of natural numbers. This type comes with two data constructors, namely =zero= and =suc=. For example, the number one is represented by =suc zero=, two by =suc (suc zero)=, etc.

#+begin_example
inductive Nat {
    zero : Nat;
    suc : Nat → Nat;
};
#+end_example

The way to use inductive types is by declaring functions by pattern matching.
Let us define, for example, the function for adding two natural numbers. 

#+begin_src text
inifl 6 +;
+ : Nat → Nat → Nat;
+ zero b ≔ b;
+ (suc a) b ≔ suc (a + b);
#+end_src

As mentioned earlier, an inductive type may have type parameters. The canonical example is the polymorphic type =List=. The type =List=s the inductive type that considers the type of the elements in the list as a parameter. A constructor to build the empty list, that is the base case, and another constructor to enlarge the list, we usually called it =cons=.
One possible definition for this type is the following type taken from the Juvix standard library:

#+begin_example
infixr 5 ∷;
inductive List (A : Type) {
  nil : List A;
  ∷ : A → List A → List A;
};

elem : {A : Type} → (A → A → Bool) → A → List A → Bool;
elem _ _ nil ≔ false;
elem eq s (x ∷ xs) ≔ eq s x || elem eq s xs;
#+end_example

To see more examples of inductive types and how to use them, please check out
[[https://anoma.github.io/juvix-stdlib/][the Juvix standard library]]