---
author: Jan Mas Rovira
---

# Monomorphization

(Removed in v0.2.5)

Monomorphization refers to the process of converting polymorphic code to
monomorphic code (no type variables) through static analysis.

Example:

```juvix
id : (A : Type) ‚Üí A ‚Üí A;
id _ a := a;

b : Bool;
b := id Bool true;

n : Nat;
n := id Nat zero;
```

Is translated into:

```juvix
id_Bool : Bool ‚Üí Bool;
id_Bool a := a;

id_Nat : Nat ‚Üí Nat;
id_Nat a := a;
```

# More examples

## Mutual recursion

```juvix
type List (A : Type) :=
  nil : List A |
  cons : A ‚Üí List A ‚Üí List A;

even : (A : Type) ‚Üí List A ‚Üí Bool;
even A nil := true ;
even A (cons _ xs) := not (odd A xs) ;

odd : (A : Type) ‚Üí List A ‚Üí Bool;
odd A nil := false ;
odd A (cons _ xs) := not (even A xs) ;

-- main := even Bool ..  odd Nat;
```

# Collection algorithm

This section describes the algorithm to collect the list of all concrete
functions and inductive definitions that need to be generated.

## Assumptions:

1.  Type abstractions only appear at the leftmost part of a type
    signature.
2.  All functions and constructors are fully type-applied: i.e. currying
    for types is not supported.
3.  There is at least one function with a concrete type signature.
4.  All axioms are monomorphic.
5.  No module parameters.

## Definitions

1.  **Application**. An application is an expression of the form
    `t‚ÇÅ t‚ÇÇ ‚Ä¶ t‚Çô` with n > 0.

2.  **Sub application**. If `t‚ÇÅ t‚ÇÇ ‚Ä¶ t‚Çô` is an application then for
    every `0<i<n` `t‚ÇÅ t‚ÇÇ ‚Ä¶ t·µ¢` is a sub application.

Fix a juvix program `P`. Let `ùí≤` be the set of all applications that
appear in `P`.

1.  **Maximal application**. A maximal application is an application
    `A‚ààùí≤` such that for every `A'‚ààùí≤` we have that `A` is **not** a sub
    application of `A'`.

2.  **Type application**. If

    1.  `t a‚ÇÅ a‚ÇÇ ‚Ä¶ a‚Çô` is a maximal application; and
    2.  `t` is either a function or an inductive type; and
    3.  `a‚ÇÅ, ‚Ä¶, a‚Çò` are types; and
    4.  `a‚Çò‚Çä‚ÇÅ` is not a type or `m = n`.

    Then `t a‚ÇÅ, ‚Ä¶, a‚Çò` is a type application.

3.  **Concrete type**. A type is concrete if it involves no type
    variables.

4.  **Concrete type application**. A type application `t a‚ÇÅ a‚ÇÇ ‚Ä¶ a‚Çô` if
    `a‚ÇÅ, a‚ÇÇ, ‚Ä¶,
a‚Çô` are concrete types.

## Option 1

Let `S‚ÇÄ` be the set of functions with a concrete type signature. Gather
all type applications (both in the type and in the body) in each of the
functions in `S‚ÇÄ`. Clearly the collected type applications are all
concrete. We now have a stack `c‚ÇÅ, c‚ÇÇ, ‚Ä¶, c‚Çô` of concrete type
applications.

1.  If the stack is empty, we are done.
2.  Otherwise pop `c‚ÇÅ` from the stack. It will be of the form
    `t a‚ÇÅ ‚Ä¶ a‚Çò`, where `t` is either an inductive or a function and
    `a‚ÇÅ, ‚Ä¶, a‚Çò` are concrete types.
3.  If the instantiation `t a‚ÇÅ ‚Ä¶ a‚Çò` has already been registered go to
    step 1. Otherwise continue to the next step.
4.  Register the instantiation `t a‚ÇÅ ‚Ä¶ a‚Çò`.
5.  If `t` is a function, then it has type variables `v‚ÇÅ, ‚Ä¶, v‚Çò`.
    Consider the substitution `œÉ = {v‚ÇÅ ‚Ü¶ a‚ÇÅ, ‚Ä¶, v‚Çò ‚Ü¶ a‚Çò}`. Consider the
    list of type applications in the body of `t`: `d‚ÇÅ, ‚Ä¶, d·µ£`. Add
    `œÉ(d‚ÇÅ), ‚Ä¶, œÉ(d·µ£)` to the stack and continue to step 1. It is easy to
    see that for any `i`, `œÉ(d·µ¢)` is a concrete type application.
6.  If `t` is an inductive type, let `d‚ÇÅ, ‚Ä¶, d·µ£` be the type
    applications that appear in the type of its constructors, then
    proceed as before.

### Correctness

It should be clear that the algorithm terminates and registers all
instantiations of constructors and functions.

# Generation algorithm

The input of this algorithm is the list of concrete type applications,
name it `‚Ñí`, produced by the collection algorithm. Example:

```juvix
List String
Pair Int Bool
Maybe String
Maybe Int
if (Maybe String)
if (Maybe Int)
if (Pair Int Bool)
```

## Name generation

Let `f √¢` be an arbitrary element of `‚Ñí`, where `√¢` is a list of
concrete types.

- If `f` is a function, assign a fresh name to `f √¢`, call it
  `‚ãÜ(f √¢)`.
- If `f` is an inductive type, assign a fresh name to `f √¢`, call it
  `‚ãÜ(f √¢)`. Then, for each constructor `c·µ¢` of `f`, where `i` is the
  index of the constructor, assign a fresh name to it and call it
  `‚ãÜ·µ¢(f √¢)`.

## Function generation

Consider an arbitrary function `f` in the original program. Then
consider the list of concrete type applications involving `f`:
`f √¢‚ÇÅ, ‚Ä¶, f √¢‚Çô`.

- If `n = 0`, then either:
  1.  `f` has a concrete type signature, in that case we proceed as
      expected.
  2.  `f` is never called from the functions with a concrete type. In
      this case we can safely ignore it.
- If `n > 1`. For each `√¢·µ¢` we proceed as follows in the next
  sections. Fix `m` to be the lenght of `√¢·µ¢` with `m > 0`.

### Function name

The name of the monomorphized function is `‚ãÜ(f √¢·µ¢)`.

### Type signature

Let `ùíÆ` be the type signature of `f`. Then `ùíÆ` has to be of the form
`(A‚ÇÅ :
 Type) ‚Üí ‚Ä¶ ‚Üí (A‚Çò : Type) ‚Üí Œ†`, where `Œ†` is a type with no type
abstractions. Now consider the substitution
`œÉ = {A‚ÇÅ ‚Ü¶ √¢·µ¢[1], ‚Ä¶, A‚Çò ‚Ü¶ √¢·µ¢[m]}`. Since `√¢·µ¢` is a list of concrete
types, it is clear that `œÉ(Œ†)` is a concrete type. Then proceed as
described in <span class="spurious-link" target="Types">_Types_</span>.

### Function clause

Let `ùíû` be a function clause of `f`. Let `p‚ÇÅ ‚Ä¶ p‚Çñ` with `k ‚â• m` be the
list of patterns in `ùíû`. Clearly the first `m` patterns must be either
variables or wildcards. Wlog assume that the first `m` patterns are all
variables, namely `v‚ÇÅ, ‚Ä¶, v‚Çò`. Let `œÉ = {v‚ÇÅ ‚Ü¶ √¢·µ¢[1], ‚Ä¶, A‚Çò ‚Ü¶ √¢·µ¢[m]}` be
a substitution. Let `e` be the body of `ùíû`, then clearly `œÉ(e)` has no
type variables in it. Now, since each name id must be bound at most
once, we need to generate new ones for the local variables bound in the
patterns `p‚Çò‚Çä‚ÇÅ, ‚Ä¶, p‚Çñ`. Let `w‚ÇÅ, ‚Ä¶, w‚Çõ` be the variables bound in
`p‚Çò‚Çä‚ÇÅ, ‚Ä¶, p‚Çñ`. Let `w'‚ÇÅ, ‚Ä¶, w'‚Çõ` be fresh variables. Then let
`Œ¥ = {w‚ÇÅ ‚Ü¶ w'‚ÇÅ, ‚Ä¶, w‚Çõ ‚Ü¶ w'‚Çõ}`.

Now let `ùíû'` have patterns `Œ¥(p‚Çò‚Çä‚ÇÅ), ‚Ä¶, Œ¥(p‚Çñ)` and let `e' :` (œÉ ‚à™
Œ¥)(e)=. It should be clear that `e'` has no type variables in it and
that all local variable references in `e'` are among `w'‚ÇÅ, ‚Ä¶, w'‚Çõ`. Note
that `e'` is not yet monomorphized. Proceed to the next step to achieve
that.

### Expressions

The input is an expression `e` that has no type variables in it. The
goal is to replace the concrete type applications by the corresponding
monomorphized expression.

The only interesting case is when we find an application. Consider the
unfolded view of the application: `f a‚ÇÅ ‚Ä¶ a‚Çò`. Then, if `f` is either a
constructor, or a function, let `A‚ÇÅ, ‚Ä¶, A‚Çñ` with `k ‚â§ m` be the list of
type parameters of `f`.

- If `f` is a function and `f a‚ÇÅ ‚Ä¶ a‚Çñ ‚àâ ‚Ñí` then recurse normally,
  otherwise, let `√¢ :` a‚ÇÅ ‚Ä¶ a‚Çñ= and replace the original expression
  `f a‚ÇÅ ‚Ä¶ a‚Çò`, by `‚ãÜ(f √¢)
a‚Çñ‚Çä‚ÇÅ' ‚Ä¶ a‚Çò'` where `a‚Çñ‚Çä‚ÇÅ' ‚Ä¶ a‚Çò'` are the monomorphization of
  `a‚Çñ‚Çä‚ÇÅ ‚Ä¶ a‚Çò` respectively.
- If `f` is a constructor, let `d` be its inductive type. Then check
  `d a‚ÇÅ ‚Ä¶ a‚Çñ
‚àà ‚Ñí`. Proceed analogously as before.

### Types

The input is a type `t` that has no type variables in it. The goal is to
replace the concrete type applications by the corresponding
monomorphized type. Proceed analogously to the previous section.
