{-# LANGUAGE QuasiQuotes #-}

module Juvix.Compiler.Pipeline.Lockfile where

import Data.Aeson.BetterErrors
import Data.Aeson.BetterErrors qualified as Aeson
import Data.Aeson.Encoding (pair)
import Data.Aeson.TH
import Data.String.Interpolate (i)
import Data.Yaml
import Data.Yaml.Pretty
import Juvix.Compiler.Pipeline.Package.Dependency
import Juvix.Compiler.Pipeline.Package.Loader.Error
import Juvix.Extra.Paths
import Juvix.Extra.Strings qualified as Str
import Juvix.Extra.Version
import Juvix.Prelude hiding ((.=))
import Juvix.Prelude.Aeson
import Lens.Micro.Platform qualified as Lens

data LockfileDependency = LockfileDependency
  { _lockfileDependencyDependency :: Dependency,
    _lockfileDependencyDependencies :: [LockfileDependency]
  }
  deriving stock (Generic, Show, Eq)

newtype Lockfile = Lockfile
  { _lockfileDependencies :: [LockfileDependency]
  }
  deriving stock (Generic, Show, Eq)

data LockfileInfo = LockfileInfo
  { _lockfileInfoPath :: Path Abs File,
    _lockfileInfoLockfile :: Lockfile
  }
  deriving stock (Eq, Show)

makeLenses ''LockfileDependency
makeLenses ''Lockfile
makeLenses ''LockfileInfo

instance ToJSON LockfileDependency where
  toJSON d = object [dep, Str.dependencies .= toJSON (d ^. lockfileDependencyDependencies)]
    where
      dep :: (Key, Value)
      dep = case d ^. lockfileDependencyDependency of
        DependencyGit g -> (Str.git, toJSON g)
        DependencyPath p -> (Str.path_, toJSON p)
  toEncoding d = pairs (dep <> pair Str.dependencies (toEncoding (d ^. lockfileDependencyDependencies)))
    where
      dep :: Series
      dep = case d ^. lockfileDependencyDependency of
        DependencyGit g -> pair Str.git (toEncoding g)
        DependencyPath p -> pair Str.path_ (toEncoding p)

instance FromJSON LockfileDependency where
  parseJSON = toAesonParser' p
    where
      p :: Parse' LockfileDependency
      p = do
        _lockfileDependencyDependency <- p'
        _lockfileDependencyDependencies <- key Str.dependencies fromAesonParser
        return LockfileDependency {..}

      p' :: Parse' Dependency
      p' = DependencyPath <$> (key Str.path_ fromAesonParser) Aeson.<|> DependencyGit <$> (key Str.git fromAesonParser)

lockfileOptions :: Options
lockfileOptions =
  defaultOptions
    { fieldLabelModifier = over Lens._head toLower . dropPrefix "_lockfile",
      rejectUnknownFields = True,
      omitNothingFields = True
    }

instance ToJSON Lockfile where
  toJSON = genericToJSON lockfileOptions
  toEncoding = genericToEncoding lockfileOptions

instance FromJSON Lockfile where
  parseJSON = toAesonParser' (Lockfile <$> (key Str.dependencies fromAesonParser))

mkPackageLockfilePath :: Path Abs Dir -> Path Abs File
mkPackageLockfilePath = (<//> juvixLockfile)

mayReadLockfile ::
  forall r.
  (Members '[Files, Error PackageLoaderError] r) =>
  Path Abs Dir ->
  Sem r (Maybe LockfileInfo)
mayReadLockfile root = do
  lockfileExists <- fileExists' lockfilePath
  if
      | lockfileExists -> do
          bs <- readFileBS' lockfilePath
          either (throwErr . pack . prettyPrintParseException) ((return . Just) . mkLockfileInfo lockfilePath) (decodeEither' @Lockfile bs)
      | otherwise -> return Nothing
  where
    mkLockfileInfo :: Path Abs File -> Lockfile -> LockfileInfo
    mkLockfileInfo _lockfileInfoPath _lockfileInfoLockfile = LockfileInfo {..}

    lockfilePath :: Path Abs File
    lockfilePath = mkPackageLockfilePath root

    throwErr :: Text -> Sem r a
    throwErr e =
      throw
        PackageLoaderError
          { _packageLoaderErrorPath = lockfilePath,
            _packageLoaderErrorCause =
              ErrLockfileYamlParseError
                LockfileYamlParseError {_lockfileYamlParseErrorError = e}
          }

lockfileEncodeConfig :: Config
lockfileEncodeConfig = setConfCompare keyCompare defConfig
  where
    -- serialize the dependencies after all other keys
    keyCompare :: Text -> Text -> Ordering
    keyCompare x y =
      if
          | y == Str.dependencies || x == Str.dependencies -> GT
          | otherwise -> compare x y

writeLockfile :: (Members '[Files] r) => Path Abs Dir -> Lockfile -> Sem r ()
writeLockfile root lf = do
  ensureDir' (parent lockfilePath)
  writeFileBS lockfilePath (header <> encodePretty lockfileEncodeConfig lf)
  where
    lockfilePath :: Path Abs File
    lockfilePath = mkPackageLockfilePath root

    header :: ByteString
    header = [i|\# This file was autogenerated by Juvix version #{versionDoc}.\n\# Do not edit this file manually.\n\n|]

-- | Extract a lockfileInfo associated with an immediate dependency. Returns Nothing
-- if the dependency is not specified at the root of the lockfile.
extractLockfileInfo :: LockfileInfo -> Dependency -> Maybe LockfileInfo
extractLockfileInfo lf d = mkLockfileInfo . (^. lockfileDependencyDependencies) <$> foundDep
  where
    foundDep :: Maybe LockfileDependency
    foundDep = find go (lf ^. lockfileInfoLockfile . lockfileDependencies)

    go :: LockfileDependency -> Bool
    go ld = case (d, ld ^. lockfileDependencyDependency) of
      (DependencyGit dg, DependencyGit ldg) -> dg ^. gitDependencyUrl == ldg ^. gitDependencyUrl
      (DependencyPath dp, DependencyPath ldp) -> dp ^. pathDependencyPath == ldp ^. pathDependencyPath
      _ -> False

    mkLockfileInfo :: [LockfileDependency] -> LockfileInfo
    mkLockfileInfo _lockfileDependencies = lf {_lockfileInfoLockfile = Lockfile {..}}
