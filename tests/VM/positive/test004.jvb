-- indirect call (stack < 10, heap < 10, steps < 70)

  move r0, hp
  move [hp], calculate
  add hp, hp, 1
  move [hp], 2
  add hp, hp, 1
  move [hp], 1
  add hp, hp, 1
  move [hp], $x
  add hp, hp, 1
  move [hp], $y
  add hp, hp, 1
  move r1, 1
  move r2, return_label_1
  move [sp], $z
  add sp, sp, 1
  jump ccall_exact
return_label_1:
  eq r0, r0, 11
  halt

-- r0 = closure
-- r2 = return address
ccall_exact:
  move r4, [r0]
  add r0, r0, 1
  move r1, [r0] -- r1 = stored args num
  add r0, r0, 1
  add r0, r0, r1
  -- now r0 points at the last stored argument
ccall_exact_loop_1:
  jumpz r1, ccall_exact_exit_1
  move [sp], [r0]
  add sp, sp, 1
  sub r0, r0, 1
  sub r1, r1, 1
  jump ccall_exact_loop_1
ccall_exact_exit_1:
  move [sp], r2
  add sp, sp, 1
  jump r4

calculate:
  sub sp, sp, 1
  move r3, [sp]
  sub sp, sp, 1
  move r0, [sp]
  sub sp, sp, 1
  move r1, [sp]
  sub sp, sp, 1
  move r2, [sp]
  move [sp], r3
  add sp, sp, 1
  mul r0, r0, r1
  add r0, r0, r2
  sub sp, sp, 1
  move r1, [sp]
  jump r1
