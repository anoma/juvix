-- indirect call

  move r0, hp
  add hp, hp, 5
  store r0, 0, calculate
  store r0, 1, 2
  store r0, 2, 1
  store r0, 3, $x
  store r0, 4, $y
  move r1, 1
  move r2, return_label_1
  store sp, 0, $z
  add sp, sp, 1
  jump ccall_exact
return_label_1:
  eq r0, r0, 11
  halt

-- r0 = closure
-- r2 = return address
ccall_exact:
  load r4, r0, 0
  load r1, r0, 1 -- r1 = stored args num
  add r0, r0, r1
  add r0, r0, 2
  -- now r0 points at the last stored argument
ccall_exact_loop_1:
  jumpz r1, ccall_exact_exit_1
  load r3, r0, 0
  store sp, 0, r3
  add sp, sp, 1
  sub r0, r0, 1
  sub r1, r1, 1
  jump ccall_exact_loop_1
ccall_exact_exit_1:
  store sp, 0, r2
  add sp, sp, 1
  jump r4

calculate:
  sub sp, sp, 1
  load r3, sp, 0
  sub sp, sp, 1
  load r0, sp, 0
  sub sp, sp, 1
  load r1, sp, 0
  sub sp, sp, 1
  load r2, sp, 0
  store sp, 0, r3
  add sp, sp, 1
  mul r0, r0, r1
  add r0, r0, r2
  sub sp, sp, 1
  load r1, sp, 0
  jump r1
