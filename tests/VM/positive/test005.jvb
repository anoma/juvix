-- lists (stack < 10, heap < 20, steps < 400)

  move r0, $x
  move [sp], return_label_1
  add sp, sp, 1
  jump gen
return_label_1:
  move [sp], r0
  add sp, sp, 1
  move r1, r0
  move r0, hp
  move [hp], plus_one
  add hp, hp, 1
  move [hp], 0
  add hp, hp, 1
  move [hp], 1
  add hp, hp, 1
  move [sp], return_label_2
  add sp, sp, 1
  jump map
return_label_2:
  sub sp, sp, 1
  move r0, [sp]
  move [sp], return_label_3
  add sp, sp, 1
  jump sum
return_label_3:
  eq r0, r0, 65
  halt

plus_one:
  sub sp, sp, 1
  move r1, [sp]
  sub sp, sp, 1
  move r0, [sp]
  add r0, r0, 1
  jump r1

sum:
  move r1, 0
sum_loop:
  jumpz r0, sum_exit
  move r2, [r0]
  add r1, r1, r2
  add r0, r0, 1
  move r0, [r0]
  jump sum_loop
sum_exit:
  move r0, r1
  sub sp, sp, 1
  move r1, [sp]
  jump r1

map:
  jumpz r1, map_exit
  move [sp], r0
  add sp, sp, 1
  move [sp], r1
  add sp, sp, 1
  move r2, map_return_1
  move [sp], [r1]
  add sp, sp, 1
  jump ccall_exact
map_return_1:
  sub sp, sp, 1
  move r1, [sp]
  move [r1], r0
  sub sp, sp, 1
  move r0, [sp]
  add r1, r1, 1
  move r1, [r1]
  jump map
map_exit:
  sub sp, sp, 1
  move r1, [sp]
  jump r1

gen:
  move r2, r0
  move r0, 0
gen_loop:
  jumpz r2, gen_loop_exit
  move r1, r0
  move r0, hp
  move [hp], r2
  add hp, hp, 1
  move [hp], r1
  add hp, hp, 1
  sub r2, r2, 1
  jump gen_loop
gen_loop_exit:
  sub sp, sp, 1
  move r1, [sp]
  jump r1

-- r0 = closure
-- r2 = return address
ccall_exact:
  move r4, [r0]
  add r0, r0, 1
  move r1, [r0] -- r1 = stored args num
  add r0, r0, 1
  add r0, r0, r1
  -- now r0 points at the last stored argument
ccall_exact_loop_1:
  jumpz r1, ccall_exact_exit_1
  move [sp], [r3]
  add sp, sp, 1
  sub r0, r0, 1
  sub r1, r1, 1
  jump ccall_exact_loop_1
ccall_exact_exit_1:
  move [sp], r2
  add sp, sp, 1
  jump r4
