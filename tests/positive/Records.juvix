module Records;

type T := mkT : T;

-- type T-wrapper := mkWrapper {unwrap : T};

type Pair (A B : Type) :=
  --- creates a pair
  mkPair {
    fst : A;
    snd : B
  };

-- p1 : Pair T T :=
--   mkPair (fst := mkT; snd := mkT);

p1prime : Pair T T
  := let
    A : Type := _;
    B : Type := _;
    fst : A := mkT;
    snd : B := mkT;
   in mkPair {A} {B} fst snd;

-- main : T := mkT;
-- type EnumRecord :=
--   | --- doc for C1
--     C1 {
--       c1a : T;
--       c1b : T
--     }
--   | C2 {
--       c2a : T;
--       c2b : T
--     };

-- p2 : Pair EnumRecord EnumRecord :=
--   mkPair
--     (fst := C1 (c1a := mkT; c1b := mkT);
--     snd := C2 (c2a := mkT; c2b := mkT));

-- type newtype := mknewtype {f : T};

-- p3 : Pair T T -> T := Pair.fst;

-- open Pair;

-- p4 {A : Type} : Pair A T -> A := fst;

-- type Bool :=
--   | false
--   | true;

-- module Update;
--   f {A B : Type} (p : Pair A B) : Pair Bool B :=
--     p@Pair{fst := true};
-- end;
