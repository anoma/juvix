module ReaderT;

import Monad open;
import Monad open using {module Monad as MMonad};
import Functor open;
import Functor open using {module Functor as MFunctor};

type ReaderT (S : Type) (M : Type → Type) (A : Type) :=
  mkReaderT {runReaderT : S → M A};

instance
ReaderT-Functor {S : Type} {M : Type → Type} {{func : Functor
  M}} : Functor (ReaderT S M) :=
  mkFunctor@{
    <$> {A B : Type} (f : A → B) : ReaderT S M A → ReaderT S M B
      | (mkReaderT g) :=
        -- NOTE we cannot use unqualified <$> or the scoper gets confused
        let
          open MFunctor;
        in mkReaderT
          λ {s := λ {a := f a} MFunctor.<$> g s}
  };

instance
ReaderT-Monad {S : Type} {M : Type → Type} {{Monad M}}
  : Monad (ReaderT S M) :=
  mkMonad@{
    functor :=
      ReaderT-Functor@{
        func := MMonad.functor
      };
    return {A : Type} (a : A) : ReaderT S M A :=
      mkReaderT λ {s := MMonad.return a};
    >>= {A B : Type} (x : ReaderT S M A) (f : A → ReaderT S M B)
      : ReaderT S M B :=
      mkReaderT
        λ {s :=
          ReaderT.runReaderT x s
            MMonad.>>= λ {a := ReaderT.runReaderT (f a) s}}
  };

import MonadReader open;
import Stdlib.Data.Unit open;

instance
ReaderT-MonadReader {S : Type} {M : Type → Type} {{Monad M}} : MonadReader S (ReaderT S M) :=
  mkMonadReader@{
    monad := ReaderT-Monad;
    ask : ReaderT S M S := mkReaderT λ {s := MMonad.return s};
  };
