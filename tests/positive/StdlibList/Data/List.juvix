module Data.List;

import Data.Bool;
open Data.Bool;

-- infixr 5 ::; waiting for implicit arguments
type List (A : Type) :=
  nil : List A
  | :: : A → List A → List A;

match : {A : Type} → {B : Type} → A → (A → B) → B;
match x f := f x;

foldr : (a : Type) → (b : Type) → (a → b → b) → b → List a → b;
foldr _ _ _ z nil := z;
foldr a b f z (:: h hs) := f h (foldr a b f z hs);

foldl : (a : Type) → (b : Type) → (b → a → b) → b → List a → b;
foldl a b f z nil := z ;
foldl a b f z (:: h hs) := foldl a b f (f z h) hs;

map : (a : Type) → (b : Type) → (a → b) → List a → List b;
map _ b f nil := nil;
map a b f (:: h hs) := :: (f h) (map a b f hs);

filter : (a : Type) → (a → Bool) → List a → List a;
filter a f nil := nil;
filter a f (:: h hs) := match (f h) λ {
  | true := :: h (filter a f hs)
  | false := filter a f hs
};

import Data.Nat;
open Data.Nat;

length : (a : Type) → List a → ℕ;
length _ nil := zero;
length a (:: _ l) := suc (length a l);

reverse : (a : Type) → List a → List a;
reverse a l :=
  let
  rev : List a → List a → List a;
  rev nil a := a;
  rev (:: x xs) a := rev xs (:: x a)
   in rev l nil;

replicate : (a : Type) → ℕ → a → List a;
replicate a zero _ := nil;
replicate a (suc n) x := :: x (replicate a n x);

take : (a : Type) → ℕ → List a → List a;
take a (suc n) (:: x xs) := :: x (take a n xs);
take a _ _ := nil;

import Data.Ord;
open Data.Ord;

import Data.Product;
open Data.Product;

splitAt : (a : Type) → ℕ → List a → List a × List a;
splitAt a _ nil := , nil nil ;
splitAt a zero xs := , nil xs;
splitAt a (suc zero) (:: x xs) := , (:: x nil) xs;
splitAt a (suc (suc m)) (:: x xs) := match (splitAt a m xs) λ {
    (, xs' xs'') := , (:: x xs') xs''
  };

terminating merge : (a : Type) → (a → a → Ordering) → List a → List a → List a;
merge a cmp (:: x xs) (:: y ys) := match (cmp x y) λ {
    | LT := :: x (merge a cmp xs (:: y ys))
    | _ := :: y (merge a cmp (:: x xs) ys)
  };
merge _ _ nil ys := ys;
merge _ _ xs nil := xs;

-- infixr 5 ++; waiting for implicit arguments
++ : (a : Type) → List a → List a → List a;
++ a nil ys := ys;
++ a (:: x xs) ys := :: x (++ a xs ys);

terminating quickSort : (a : Type) → (a → a → Ordering) → List a → List a;
quickSort a _ nil := nil;
quickSort a _ (:: x nil) := :: x nil;
quickSort a cmp (:: x ys) :=
  let
    ltx : a → Bool;
    ltx y := match (cmp y x) λ{
      | LT := true
      | _  := false
    };
    gex : a → Bool;
    gex y := not (ltx y)
   in
     ++ a (quickSort a cmp (filter a ltx ys))
    (++ a (:: x nil) (quickSort a cmp (filter a gex ys)));

end;
