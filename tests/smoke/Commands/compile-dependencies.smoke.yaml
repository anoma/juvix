working-directory: ./../../../

tests:
  - name: git-dependencies-success
    command:
      shell:
        - bash
      script: |
        temp=$(mktemp -d)
        trap 'rm -rf -- "$temp"' EXIT

        # create dependency
        mkdir $temp/dep
        cd $temp/dep
        git init

        cat <<-EOF > HelloDep.juvix
        module HelloDep;
        import Stdlib.Prelude open;
        main : IO := printStringLn "Hello from dep";
        EOF
        touch juvix.yaml

        git add -A
        git commit -m "commit1"

        dep1hash=$(git rev-parse HEAD)

        # create project that uses dependency
        mkdir $temp/base
        cd $temp/base

        cat <<-EOF > juvix.yaml
        name: HelloWorld
        main: HelloWorld.juvix
        dependencies:
          - .juvix-build/stdlib
          - git:
              url: $temp/dep
              name: dep1
              ref: $dep1hash
        version: 0.1.0
        EOF

        cat <<-EOF > HelloWorld.juvix
        -- HelloWorld.juvix
        module HelloWorld;

        import Stdlib.Prelude open;
        import HelloDep;

        main : IO := HelloDep.main;
        EOF

        # compile project
        juvix compile HelloWorld.juvix
        ./HelloWorld
    stdout:
      contains: Hello from dep
    exit-status: 0

  - name: git-dependencies-success-then-offline
    command:
      shell:
        - bash
      script: |
        temp=$(mktemp -d)
        trap 'rm -rf -- "$temp"' EXIT

        # create dependency
        mkdir $temp/dep
        cd $temp/dep
        git init

        cat <<-EOF > HelloDep.juvix
        module HelloDep;
        import Stdlib.Prelude open;
        main : IO := printStringLn "Hello from dep";
        EOF
        touch juvix.yaml

        git add -A
        git commit -m "commit1"

        dep1hash=$(git rev-parse HEAD)

        # create project that uses dependency
        mkdir $temp/base
        cd $temp/base

        cat <<-EOF > juvix.yaml
        name: HelloWorld
        main: HelloWorld.juvix
        dependencies:
          - .juvix-build/stdlib
          - git:
              url: $temp/dep
              name: dep1
              ref: $dep1hash
        version: 0.1.0
        EOF

        cat <<-EOF > HelloWorld.juvix
        -- HelloWorld.juvix
        module HelloWorld;

        import Stdlib.Prelude open;
        import HelloDep;

        main : IO := HelloDep.main;
        EOF

        # compile project
        juvix compile HelloWorld.juvix

        # Delete the dependency
        rm -rf $temp/dep
        rm HelloWorld

        # Compile using the offline clone
        juvix --offline compile HelloWorld.juvix
        ./HelloWorld
    stdout:
      contains: Hello from dep
    exit-status: 0

  - name: git-dependencies-fetch-new-commits
    command:
      shell:
        - bash
      script: |
        temp=$(mktemp -d)
        trap 'rm -rf -- "$temp"' EXIT

        # create dependency
        mkdir $temp/dep
        cd $temp/dep
        git init

        cat <<-EOF > HelloDep.juvix
        module HelloDep;
        import Stdlib.Prelude open;
        main : IO := printStringLn "Hello from dep";
        EOF
        touch juvix.yaml

        git add -A
        git commit -m "commit1"

        dep1hash=$(git rev-parse HEAD)

        # create project that uses dependency
        mkdir $temp/base
        cd $temp/base

        cat <<-EOF > juvix.yaml
        name: HelloWorld
        main: HelloWorld.juvix
        dependencies:
          - .juvix-build/stdlib
          - git:
              url: $temp/dep
              name: dep1
              ref: $dep1hash
        version: 0.1.0
        EOF

        cat <<-EOF > HelloWorld.juvix
        -- HelloWorld.juvix
        module HelloWorld;

        import Stdlib.Prelude open;
        import HelloDep;

        main : IO := HelloDep.main;
        EOF

        # compile project the first time
        juvix compile HelloWorld.juvix

        # update the dependency
        cd $temp/dep

        cat <<-EOF > HelloDep.juvix
        module HelloDep;
        import Stdlib.Prelude open;
        main : IO := printStringLn "This is from the second commit";
        EOF

        git add -A
        git commit -m "commit2"

        dep1hash=$(git rev-parse HEAD)

        # use the new hash
        cd $temp/base

        cat <<-EOF > juvix.yaml
        name: HelloWorld
        main: HelloWorld.juvix
        dependencies:
          - .juvix-build/stdlib
          - git:
              url: $temp/dep
              name: dep1
              ref: $dep1hash
        version: 0.1.0
        EOF

        # compile with the new hash
        juvix compile HelloWorld.juvix
        ./HelloWorld
    stdout:
      contains: This is from the second commit
    exit-status: 0

  - name: git-dependencies-update-ref-offline
    command:
      shell:
        - bash
      script: |
        temp=$(mktemp -d)
        trap 'rm -rf -- "$temp"' EXIT

        # create dependency
        mkdir $temp/dep
        cd $temp/dep
        git init

        # Make the first commit
        cat <<-EOF > HelloDep.juvix
        module HelloDep;
        import Stdlib.Prelude open;
        main : IO := printStringLn "Hello from dep";
        EOF
        touch juvix.yaml

        git add -A
        git commit -m "commit1"

        dep1hash1=$(git rev-parse HEAD)

        # Make the second commit
        cat <<-EOF > HelloDep.juvix
        module HelloDep;
        import Stdlib.Prelude open;
        main : IO := printStringLn "This is from the second commit";
        EOF

        git add -A
        git commit -m "commit2"

        dep1hash2=$(git rev-parse HEAD)

        # create project that uses dependency
        mkdir $temp/base
        cd $temp/base

        cat <<-EOF > juvix.yaml
        name: HelloWorld
        main: HelloWorld.juvix
        dependencies:
          - .juvix-build/stdlib
          - git:
              url: $temp/dep
              name: dep1
              ref: $dep1hash1
        version: 0.1.0
        EOF

        cat <<-EOF > HelloWorld.juvix
        -- HelloWorld.juvix
        module HelloWorld;

        import Stdlib.Prelude open;
        import HelloDep;

        main : IO := HelloDep.main;
        EOF

        # compile project the first time
        # It should use code from the first commit
        juvix compile HelloWorld.juvix
        output=$(./HelloWorld)

        if [ "$output" != "Hello from dep" ]; then
          exit 1
        fi

        # Update the ref and compile in offline mode
        # It should use code from the second commit
        cat <<-EOF > juvix.yaml
        name: HelloWorld
        main: HelloWorld.juvix
        dependencies:
          - .juvix-build/stdlib
          - git:
              url: $temp/dep
              name: dep1
              ref: $dep1hash2
        version: 0.1.0
        EOF

        juvix --offline compile HelloWorld.juvix
        ./HelloWorld
    stdout:
      contains: This is from the second commit
    exit-status: 0

  - name: git-dependencies-invalid-ref
    command:
      shell:
        - bash
      script: |
        temp=$(mktemp -d)
        trap 'rm -rf -- "$temp"' EXIT

        # create dependency
        mkdir $temp/dep
        cd $temp/dep
        git init

        cat <<-EOF > HelloDep.juvix
        module HelloDep;
        import Stdlib.Prelude open;
        main : IO := printStringLn "Hello from dep";
        EOF
        touch juvix.yaml

        git add -A
        git commit -m "commit1"

        # create project that uses dependency
        mkdir $temp/base
        cd $temp/base

        cat <<-EOF > juvix.yaml
        name: HelloWorld
        main: HelloWorld.juvix
        dependencies:
          - .juvix-build/stdlib
          - git:
              url: $temp/dep
              name: dep1
              ref: invalid-ref
        version: 0.1.0
        EOF

        cat <<-EOF > HelloWorld.juvix
        -- HelloWorld.juvix
        module HelloWorld;

        import Stdlib.Prelude open;
        import HelloDep;

        main : IO := HelloDep.main;
        EOF

        # compile project
        juvix compile HelloWorld.juvix
    stderr:
      contains: invalid-ref
    stdout:
      contains: cloning
    exit-status: 1

  - name: git-dependencies-invalid-url
    command:
      shell:
        - bash
      script: |
        temp=$(mktemp -d)
        trap 'rm -rf -- "$temp"' EXIT

        # create project that uses dependency
        mkdir $temp/base
        cd $temp/base

        cat <<-EOF > juvix.yaml
        name: HelloWorld
        main: HelloWorld.juvix
        dependencies:
          - .juvix-build/stdlib
          - git:
              url: $temp/dep
              name: dep1
              ref: main
        version: 0.1.0
        EOF

        cat <<-EOF > HelloWorld.juvix
        -- HelloWorld.juvix
        module HelloWorld;

        import Stdlib.Prelude open;
        import HelloDep;

        main : IO := HelloDep.main;
        EOF

        # compile project
        juvix compile HelloWorld.juvix
    stderr:
      contains: error
    stdout:
      contains: cloning
    exit-status: 1

  - name: git-dependencies-offline
    command:
      shell:
        - bash
      script: |
        temp=$(mktemp -d)
        trap 'rm -rf -- "$temp"' EXIT

        # create project that uses dependency
        mkdir $temp/base
        cd $temp/base

        cat <<-EOF > juvix.yaml
        name: HelloWorld
        main: HelloWorld.juvix
        dependencies:
          - .juvix-build/stdlib
          - git:
              url: $temp/dep
              name: dep1
              ref: main
        version: 0.1.0
        EOF

        cat <<-EOF > HelloWorld.juvix
        -- HelloWorld.juvix
        module HelloWorld;

        import Stdlib.Prelude open;
        import HelloDep;

        main : IO := HelloDep.main;
        EOF

        # compile project
        juvix --offline compile HelloWorld.juvix
    stderr:
      contains: dep1
    stdout:
      matches:
        # compile should not attempt to clone the dependency
        regex: |-
          ^((?!cloning).)*$
        options:
          - dot-all
    exit-status: 1

  - name: git-dependencies-corrupt-clone
    command:
      shell:
        - bash
      script: |
        temp=$(mktemp -d)
        trap 'rm -rf -- "$temp"' EXIT

        # create dependency
        mkdir $temp/dep
        cd $temp/dep
        git init

        cat <<-EOF > HelloDep.juvix
        module HelloDep;
        import Stdlib.Prelude open;
        main : IO := printStringLn "Hello from dep";
        EOF
        touch juvix.yaml

        git add -A
        git commit -m "commit1"

        dep1hash=$(git rev-parse HEAD)

        # create project that uses dependency
        mkdir $temp/base
        cd $temp/base

        cat <<-EOF > juvix.yaml
        name: HelloWorld
        main: HelloWorld.juvix
        dependencies:
          - .juvix-build/stdlib
          - git:
              url: $temp/dep
              name: dep1
              ref: $dep1hash
        version: 0.1.0
        EOF

        cat <<-EOF > HelloWorld.juvix
        -- HelloWorld.juvix
        module HelloWorld;

        import Stdlib.Prelude open;
        import HelloDep;

        main : IO := HelloDep.main;
        EOF

        # compile project
        juvix compile HelloWorld.juvix

        # corrupt the clone
        rm -rf ./.juvix-build/deps/dep1/.git

        # compile project
        juvix compile HelloWorld.juvix
    stderr:
      contains: juvix clean
    stdout:
      contains: cloning
    exit-status: 1

  - name: git-dependencies-duplicate-names
    command:
      shell:
        - bash
      script: |
        temp=$(mktemp -d)
        trap 'rm -rf -- "$temp"' EXIT

        # create project that uses dependency
        mkdir $temp/base
        cd $temp/base

        cat <<-EOF > juvix.yaml
        name: HelloWorld
        main: HelloWorld.juvix
        dependencies:
          - .juvix-build/stdlib
          - git:
              url: $temp/dep
              name: dep1
              ref: main
          - git:
              url: $temp/dep2
              name: dep1
              ref: main
        version: 0.1.0
        EOF

        cat <<-EOF > HelloWorld.juvix
        -- HelloWorld.juvix
        module HelloWorld;

        import Stdlib.Prelude open;
        import HelloDep;

        main : IO := HelloDep.main;
        EOF

        # compile project
        juvix compile HelloWorld.juvix
    stdout:
      contains: duplicate
    exit-status: 1
