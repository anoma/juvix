--- translated from https://github.com/anoma/anoma/blob/61413dfc6460b7bf96e9207ce3b9d22b9c678f09/apps/anoma_node/lib/examples/e_transaction.ex#L309
module Swap;

import Stdlib.Prelude open;
import ResourceMachine open;
import TransactionRequest open;
import Stdlib.Debug.Trace open;
import ByteArray open;

axiom undefined {A} : A;

open Public-Inputs;
open Private-Inputs;

createdMagic : Nat := 200;

consumedMagic : Nat := 100;

mylogic (pub : Public-Inputs) (priv : Private-Inputs) : Bool :=
  -- DANGER we assume that the list of commitments and committed-resources come in the same order. This is NOT the case in the specs. Same for the nullifiers
  let
    coms : List (Pair Nat Resource) :=
      zip (commitments pub) (committed-resources priv);
    nulls : List (Pair Nat Resource) :=
      zip (nullifiers pub) (nullified-resources priv);
    st : Nat := self-tag pub;

    isCommit (r : Resource) : Bool := commitment r == st;
    isNullifier (r : Resource) : Bool := nullifier r == st;
    findCommit : Maybe Resource := find isCommit (committed-resources priv);
    findNullifier : Maybe Resource :=
      find isNullifier (nullified-resources priv);

  in case findCommit of
       | just createdResource :=
         Resource.quantity createdResource == 1
           && other-public pub == createdMagic
           && other-private priv == createdMagic
       | nothing :=
         case findNullifier of
           | nothing := false
           | just consumedResource :=
             Resource.quantity consumedResource == 1
               && other-public pub == consumedMagic
               && other-private priv == consumedMagic;

myResourceEph : Resource :=
  mkResource@{
    label := 0;
    logic := mylogic;
    ephemeral := true;
    quantity := 1;
    data := 0;
    nullifier-key := replicate 32 0x0 |> mkByteArray |> toAnomaContents;
    rseed := 0;
    nonce := replicate 32 0x0 |> mkByteArray |> toAnomaContents;
  };

myResource : Resource :=
  mkResource@{
    label := 0;
    logic := mylogic;
    ephemeral := false;
    quantity := 1;
    data := 0;
    nullifier-key := replicate 32 0x0 |> mkByteArray |> toAnomaContents;
    rseed := 0;
    nonce := 2;
  };

myResource' : Resource := myResource@Resource{nonce := 222};

myResourceEph' : Resource := myResourceEph@Resource{nonce := 333};

myResourceCommitment' : Nat := commitment myResource';

myResourceCommitment : Nat := commitment myResource;

myResourceEphNullifier : Nat := nullifier myResourceEph;

myResourceEphNullifier' : Nat := nullifier myResourceEph';

mycommitments : List Nat := [myResourceCommitment; myResourceCommitment'];

mynullifiers : List Nat := [myResourceEphNullifier; myResourceEphNullifier'];

mycommitted-resources : List Resource := [myResource; myResource'];

mynullified-resources : List Resource := [myResourceEph; myResourceEph'];

myResourceEphProof : Proof :=
  let
    publicInputs : Public-Inputs :=
      mkPublic-Inputs@{
        commitments := mycommitments;
        nullifiers := mynullifiers;
        self-tag := myResourceEphNullifier;
        other-public := consumedMagic;
      };
    privateInputs : Private-Inputs :=
      mkPrivate-Inputs@{
        committed-resources := mycommitted-resources;
        nullified-resources := mynullified-resources;
        other-private := consumedMagic;
      };
  in mkProofLogic myResourceEph publicInputs privateInputs;

myResourceEphProof' : Proof :=
  let
    publicInputs : Public-Inputs :=
      mkPublic-Inputs@{
        commitments := mycommitments;
        nullifiers := mynullifiers;
        self-tag := myResourceEphNullifier';
        other-public := consumedMagic;
      };
    privateInputs : Private-Inputs :=
      mkPrivate-Inputs@{
        committed-resources := mycommitted-resources;
        nullified-resources := mynullified-resources;
        other-private := consumedMagic;
      };
  in mkProofLogic myResourceEph' publicInputs privateInputs;

myResourceProof : Proof :=
  let
    publicInputs : Public-Inputs :=
      mkPublic-Inputs@{
        commitments := mycommitments;
        nullifiers := mynullifiers;
        self-tag := myResourceCommitment;
        other-public := createdMagic;
      };
    privateInputs : Private-Inputs :=
      mkPrivate-Inputs@{
        committed-resources := mycommitted-resources;
        nullified-resources := mynullified-resources;
        other-private := createdMagic;
      };
  in mkProofLogic myResource publicInputs privateInputs;

myResourceProof' : Proof :=
  let
    publicInputs : Public-Inputs :=
      mkPublic-Inputs@{
        commitments := mycommitments;
        nullifiers := mynullifiers;
        self-tag := myResourceCommitment';
        other-public := createdMagic;
      };
    privateInputs : Private-Inputs :=
      mkPrivate-Inputs@{
        committed-resources := mycommitted-resources;
        nullified-resources := mynullified-resources;
        other-private := createdMagic;
      };
  in mkProofLogic myResource' publicInputs privateInputs;

myproofs : List Proof :=
  [
    myResourceProof';
    myResourceEphProof';
    myResourceProof;
    myResourceEphProof;
  ];

tx-action : Action :=
  mkAction@{
    commitments := mycommitments;
    nullifiers := mynullifiers;
    proofs := myproofs;
    app-data := 0; -- Ask Yulia why this app-data does not correspond to other-public
  };

tx : Transaction :=
  mkTransaction@{
    roots := [];
    delta := actionDelta tx-action;
    actions := [tx-action];
    delta-proof := 0;
  };

main : TransactionRequest := TransactionRequest.fromTransaction tx;
