--- translated from https://github.com/anoma/anoma/blob/61413dfc6460b7bf96e9207ce3b9d22b9c678f09/apps/anoma_node/lib/examples/e_transaction.ex#L309
module Swap;

import Stdlib.Prelude open;
import ResourceMachine open;
import TransactionRequest open;
import Stdlib.Debug.Trace open;
import ByteArray open;

axiom undefined {A} : A;

open Public-Inputs;
open Private-Inputs;

mylogic (pub : Public-Inputs) (priv : Private-Inputs) : Bool :=
  -- DANGER we assume that the list of commitments and committed-resources come in the same order. This is NOT the case in the specs. Same for the nullifiers
  let
    coms : List (Pair Nat Resource) :=
      zip (commitments pub) (committed-resources priv);
    nulls : List (Pair Nat Resource) :=
      zip (nullifiers pub) (nullified-resources priv);
    st : Nat := self-tag pub;

    isCommit (r : Resource) : Bool := commitment r == st;
    isNullifier (r : Resource) : Bool := nullifier r == st;
    findCommit : Maybe Resource := find isCommit (committed-resources priv);
    findNullifier : Maybe Resource :=
      find isNullifier (nullified-resources priv);

  in case findCommit of
       | just createdResource :=
         Resource.quantity createdResource == 1 && other-public pub == 200
       | nothing :=
         case findNullifier of
           | nothing := false
           | just consumedResource :=
             Resource.quantity consumedResource == 1 && other-public pub == 100;

myResourceEph : Resource :=
  mkResource@{
    label := 0;
    logic := mylogic;
    ephemeral := true;
    quantity := 1;
    data := 0;
    nullifier-key := replicate 32 0x0 |> mkByteArray |> toAnomaContents;
    rseed := 0;
    nonce := replicate 32 0x0 |> mkByteArray |> toAnomaContents;
  };

myResourceEphNullifier : Nat := nullifier myResourceEph;

myResource : Resource :=
  mkResource@{
    label := 0;
    logic := mylogic;
    ephemeral := true;
    quantity := 1;
    data := 0;
    nullifier-key := replicate 32 0x0 |> mkByteArray |> toAnomaContents;
    rseed := 0;
    nonce := 2;
  };

myResourceCommitment : Nat := commitment myResource;

myResourceEphProof : Proof :=
  let
    publicInputs : Public-Inputs :=
      mkPublic-Inputs@{
        commitments := [myResourceCommitment];
        nullifiers := [myResourceEphNullifier];
        self-tag := myResourceEphNullifier;
        other-public := 100;
      };
    privateInputs : Private-Inputs :=
      mkPrivate-Inputs@{
        committed-resources := [myResource];
        nullified-resources := [myResourceEph];
        other-private := 0;
      };
  in mkProofLogic myResourceEph publicInputs privateInputs;

myResourceProof : Proof :=
  let
    publicInputs : Public-Inputs :=
      mkPublic-Inputs@{
        commitments := [myResourceCommitment];
        nullifiers := [myResourceEphNullifier];
        self-tag := myResourceCommitment;
        other-public := 200;
      };
    privateInputs : Private-Inputs :=
      mkPrivate-Inputs@{
        committed-resources := [myResource];
        nullified-resources := [myResourceEph];
        other-private := 0;
      };
  in mkProofLogic myResource publicInputs privateInputs;

tx-action : Action :=
  mkAction@{
    commitments := [myResourceCommitment];
    nullifiers := [myResourceEphNullifier];
    proofs := [myResourceProof; myResourceEphProof];
    app-data := 0;
  };

tx : Transaction :=
  mkTransaction@{
    roots := [];
    delta := actionDelta tx-action;
    actions := [tx-action];
    delta-proof := 0;
  };

main : TransactionRequest := TransactionRequest.fromTransaction tx;
