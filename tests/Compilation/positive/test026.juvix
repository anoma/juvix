-- functional queues
module test026;

open import Stdlib.Prelude;

type Queue (A : Type) := queue : List A → List A → Queue A;

qfst : {A : Type} → Queue A → List A;
qfst (queue x _) := x;

qsnd : {A : Type} → Queue A → List A;
qsnd (queue _ x) := x;

front : {A : Type} → Queue A → A;
front q := head (qfst q);

pop_front : {A : Type} → Queue A → Queue A;
pop_front {A} q :=
  let q' : Queue A; q' := queue (tail (qfst q)) (qsnd q) in
  case qfst q'
    | nil := queue (reverse (qsnd q')) nil
    | _ := q'
  ;

push_back : {A : Type} → Queue A → A → Queue A;
push_back q x := case qfst q
  | nil := queue (x :: nil) (qsnd q)
  | q' := queue q' (x :: qsnd q);

is_empty : {A : Type} → Queue A → Bool;
is_empty q := case qfst q
  | nil := (case qsnd q | nil := true | _ := false)
  | _ := false;

empty : {A : Type} → Queue A;
empty := queue nil nil;

terminating
g : List Nat → Queue Nat → List Nat;
g acc q := if (is_empty q) acc (g (front q :: acc) (pop_front q));

f : Nat → Queue Nat → List Nat;
f zero q := g nil q;
f n@(suc n') q := f n' (push_back q n);

printListNatLn : List Nat → IO;
printListNatLn nil := printStringLn "nil";
printListNatLn (h :: t) := printNatLn h >> printString " :: " >> printListNatLn t;

main : IO;
main := printListNatLn (f 100 empty); -- list of numbers from 1 to 100

end;
