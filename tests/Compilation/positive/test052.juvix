--- Simple lambda calculus
module test052;

open import Stdlib.Prelude;

fromShow : {a : Type} -> Show a -> a -> String;
fromShow (mkShow s) a := s a;

LambdaTy : Type -> Type;

AppTy : Type -> Type;

syntax infixl 6 :+:;
--- An ;Expr'; is an expression in our language.
type Expr' (v : Type) :=
  | ! : v -> Expr' v
  | lam : LambdaTy v -> Expr' v
  | app : AppTy v -> Expr' v
  | :+: : Expr' v -> Expr' v -> Expr' v
  | num : Nat -> Expr' v;

--- A ;Lambda'; is a lambda function.
type Lambda' (v : Type) :=
  | mkLambda : Expr' v -> Lambda' v;

--- An ;App'; is an application of two ;Expr';.
type App' (v : Type) :=
  | mkApp : Expr' v -> Expr' v -> App' v;

LambdaTy := Lambda';

AppTy := App';

Expr : Type;
Expr := Expr' Nat;

Lambda : Type;
Lambda := Lambda' Nat;

App : Type;
App := App' Nat;

ValTy : Type -> Type;

--- A ;Closure'; is a context (;List; of ;ValTy;) and an ;Expr'; in that context.
type Closure' (v : Type) :=
  | mkClosure : List (ValTy v) -> Expr' v -> Closure' v;

--- A ;Val'; is either a ;Closure'; or a ;Nat;.
type Val' (v : Type) :=
  | vnum : Nat -> Val' v
  | closure : Closure' v -> Val' v;

ValTy := Val';

Val : Type;
Val := Val' Nat;

Closure : Type;
Closure := Closure' Nat;

--- Sum type.
type Either (a : Type) (b : Type) :=
  | left : a -> Either a b
  | right : b -> Either a b;

module ExprTraits;
  toString : Expr -> String;
  toString (! v) := "[" ++str natToString v ++str "]";
  toString (lam (mkLambda b)) :=
    "\955 {" ++str toString b ++str "}";
  toString (app (mkApp l r)) :=
    "("
      ++str toString l
      ++str " # "
      ++str toString r
      ++str ")";
  toString (l :+: r) :=
    "("
      ++str toString l
      ++str " + "
      ++str toString r
      ++str ")";
  toString (num n) := natToString n;

  --- ;Show; instance for ;Expr;.
  Show : Show Expr;
  Show := mkShow toString;
end;

module ValTraits;
  terminating
  valToString : Val -> String;

  --- ;Show; instance for ;Val;.
  terminating
  Show : Show Val;
  Show := mkShow valToString;

  valToString (vnum n) := natToString n;
  valToString (closure (mkClosure ctx n)) :=
    fromShow (ListTraits.Show Show) ctx
      ++str " \8866 "
      ++str ExprTraits.toString n;
end;

syntax infixl 1 >>=;
--- Monadic binding for ;Either;.
>>= :
  {e a b : Type}
    -> Either e a
    -> (a -> Either e b)
    -> Either e b;
>>= (left e) _ := left e;
>>= (right a) f := f a;

--- An evaluation error.
type Error :=
  | --- A variable outside of the context was found.
    ScopeError : Nat -> List Val -> Error
  | --- A nat was expected.
    ExpectedNat : Val -> Error
  | --- A lambda was expected.
    ExpectedLambda : Error;

--- Returns the first item of a ;List;, if it exists.
headMay : {a : Type} -> List a -> Maybe a;
headMay nil := nothing;
headMay (x :: _) := just x;

--- ;List; indexing.
index : {a : Type} -> List a -> Nat -> Maybe a;
index l n := headMay (drop n l);

--- Get a ;Nat; from a ;Val; or return an ;Error;.
getNat : Val -> Either Error Nat;
getNat (vnum n) := right n;
getNat e := left (ExpectedNat e);

--- Evaluates an ;Expr; and returns a ;Val;.
--- If an error occurs during evaluation, returns ;Error;.
eval : Expr -> Either Error Val;
eval topExpr :=
  let
    getClosure : Val -> Either Error Closure;
    getClosure (closure l) := right l;
    getClosure _ := left ExpectedLambda;
    terminating
    go : List Val -> Expr -> Either Error Val;
    go ctx (! v) :=
      maybe (left (ScopeError v ctx)) right (index ctx v);
    go ctx (app (mkApp fun x)) :=
      let
        terminating
        applyClosure : Closure -> Either Error Val;
        applyClosure (mkClosure closCtx body) :=
          go ctx x
            >>= λ {
              | x' := go (x' :: closCtx) body
            };
      in go ctx fun >>= getClosure >>= applyClosure;
    go ctx (lam (mkLambda body)) :=
      right (closure (mkClosure ctx body));
    go _ (num n) := right (vnum n);
    go ctx (l :+: r) :=
      go ctx l
        >>= getNat
        >>= λ {
          | l' :=
            go ctx r
              >>= getNat
              >>= λ {
                | r' := right (vnum (l' + r'))
              }
        };
  in go nil topExpr;

--- Evaluate an ;Expr; and try to extract a ;Nat;.
terminating
evalNat : Expr -> Either Error Nat;
evalNat topExpr := eval topExpr >>= getNat;

--- Syntactical helper for creating a ;lam;.
Λ : Expr -> Expr;
Λ body := lam (mkLambda body);

syntax infixl 9 #;
--- Syntactical helper for creating an ;app;.
# : Expr -> Expr -> Expr;
# f x := app (mkApp f x);

--- ;Expr; that doubles a number.
double : Expr;
double := Λ (! 0 :+: ! 0);

--- ;Expr; that adds 1 to a number.
+1 : Expr;
+1 := Λ (! 0 :+: num 1);

apps : Expr -> List Expr -> Expr;
apps := foldl (#);

--- ;Expr; for function composition.
compose : Expr;
compose := Λ (Λ (Λ (! 2 # (! 1 # ! 0))));

double+1 : Expr;
double+1 := Λ (compose # +1 # double # ! 0);

res : Either Error Val;
res := eval (double+1 # num 7);

main : IO;
main :=
  case res
    | left (ScopeError n ctx) :=
      printStringLn
        ("ScopeError: "
          ++str natToString n
          ++str ", ctx = "
          ++str fromShow (ListTraits.Show ValTraits.Show) ctx
          ++str "\n")
    | left (ExpectedNat e) :=
      printStringLn
        ("Expected a natural but got "
          ++str ValTraits.valToString e)
    | left ExpectedLambda := printStringLn "ExpectedLambda"
    | right r := printStringLn (ValTraits.valToString r);
