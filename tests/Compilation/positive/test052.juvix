-- lambda calculus
module test052;

open import Stdlib.Prelude;

fromShow : {a : Type} -> Show a -> a -> String;
fromShow (mkShow s) a := s a;

LambdaTy : Type -> Type;

AppTy : Type -> Type;

infixl 6 :+:;
-- we parameterize the variables type for testing purposes.
type Expr' (v : Type) :=
  | ! : v -> Expr' v
  | lam : LambdaTy v -> Expr' v
  | app : AppTy v -> Expr' v
  | :+: : Expr' v -> Expr' v -> Expr' v
  | num : Nat -> Expr' v;

type Lambda' (v : Type) :=
  | mkLambda : Expr' v -> Lambda' v;

type App' (v : Type) :=
  | mkApp : Expr' v -> Expr' v -> App' v;

LambdaTy := Lambda';

AppTy := App';

Expr : Type;
Expr := Expr' Nat;

Lambda : Type;
Lambda := Lambda' Nat;

App : Type;
App := App' Nat;

ValTy : Type -> Type;

type Closure' (v : Type) :=
 mkClosure : List (ValTy v) -> Expr' v -> Closure' v;

type Val' (v : Type) :=
  | vnum : Nat -> Val' v
  | closure : Closure' v -> Val' v;

ValTy := Val';

Val : Type;
Val := Val' Nat;

Closure : Type;
Closure := Closure' Nat;

type Either (a : Type) (b : Type) :=
  | left : a -> Either a b
  | right : b -> Either a b;

toString : Expr -> String;
toString (! v) := "[" ++str natToString v ++str "]";
toString (lam (mkLambda b)) :=
  "\955 {" ++str toString b ++str "}";
toString (app (mkApp l r)) :=
  "("
    ++str toString l
    ++str " # "
    ++str toString r
    ++str ")";
toString (l :+: r) :=
  "("
    ++str toString l
    ++str " + "
    ++str toString r
    ++str ")";
toString (num n) := natToString n;

module ExprTraits;
  Show : Show Expr;
  Show := mkShow toString;
end;

module ValTraits;
  terminating valToString : Val -> String;

  terminating Show : Show Val;
  Show := mkShow valToString;

  valToString (vnum n) := natToString n;
  valToString (closure (mkClosure ctx n)) := fromShow (ListTraits.Show Show) ctx ++str " ⊢ " ++str toString n;
end;

infixl 1 >>=;
>>= :
  {e a b : Type}
    -> Either e a
    -> (a -> Either e b)
    -> Either e b;
>>= (left e) _ := left e;
>>= (right a) f := f a;

type Error :=
  | ScopeError : Nat -> List Val -> Error
  | ExpectedNat : Val -> Error
  | ExpectedLambda : Error;

headMay : {a : Type} -> List a -> Maybe a;
headMay nil := nothing;
headMay (x :: _) := just x;

index : {a : Type} -> List a -> Nat -> Maybe a;
index l n := headMay (drop n l);

getNat : Val -> Either Error Nat;
getNat (vnum n) := right n;
getNat e := left (ExpectedNat e);

eval : Expr -> Either Error Val;
eval topExpr :=
  let
    getClosure : Val -> Either Error Closure;
    getClosure (closure l) := right l;
    getClosure _ := left ExpectedLambda;
    terminating
    go : List Val -> Expr -> Either Error Val;
    go ctx (! v) :=
      maybe (left (ScopeError v ctx)) right (index ctx v);
    go ctx (app (mkApp fun x)) :=
      let
        terminating
        applyClosure : Closure -> Either Error Val;
        applyClosure (mkClosure closCtx body) :=
          go ctx x
            >>= λ {
              | x' := go (x' :: closCtx) body
            };
      in go ctx fun >>= getClosure >>= applyClosure;
    go ctx (lam (mkLambda body)) := right (closure (mkClosure ctx body));
    go _ (num n) := right (vnum n);
    go ctx (l :+: r) :=
      go ctx l
        >>= getNat
        >>= λ {
          | l' :=
            go ctx r
              >>= getNat
              >>= λ {
                | r' := right (vnum (l' + r'))
              }
        };
  in go nil topExpr;

terminating
evalNat : Expr -> Either Error Nat;
evalNat topExpr := eval topExpr >>= getNat;

Λ : Expr -> Expr;
Λ body := lam (mkLambda body);

infixl 9 #;
# : Expr -> Expr -> Expr;
# f x := app (mkApp f x);

--- Doubles a number
double : Expr;
double := Λ (! 0 :+: ! 0);

+1 : Expr;
+1 := Λ (! 0 :+: num 1);

apps : Expr -> List Expr -> Expr;
apps := foldl (#);

compose : Expr;
compose := Λ (Λ (Λ (! 2 # (! 1 # ! 0))));

double+1 : Expr;
double+1 := Λ (compose # +1 # double # ! 0);

res2 : Either Error Val;
res2 := eval (double+1 # num 9);

main : IO;
main :=
  case res2
    | left (ScopeError n ctx) :=
      printStringLn
        ("ScopeError: "
          ++str natToString n
          ++str ", ctx = "
          ++str fromShow (ListTraits.Show ValTraits.Show) ctx
          ++str "\n")
    | left (ExpectedNat e) :=
      printStringLn
        ("Expected a natural but got " ++str ValTraits.valToString e)
    | left ExpectedLambda := printStringLn "ExpectedLambda"
    | right r := printStringLn (ValTraits.valToString r);
