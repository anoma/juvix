-- merge sort
module test032;

import Stdlib.Prelude open;
import Stdlib.Data.Nat.Ord open;

split : {A : Type} → Nat → List A → List A × List A
  | zero xs := nil, xs
  | (suc n) nil := nil, nil
  | (suc n) (x :: xs) :=
    case split n xs
      | l1, l2 := x :: l1, l2;

terminating
merge' : List Nat → List Nat → List Nat
  | nil ys := ys
  | xs nil := xs
  | xs@(x :: xs') ys@(y :: ys') :=
    if (x <= y) (x :: merge' xs' ys) (y :: merge' xs ys');

terminating
sort : List Nat → List Nat
  | xs :=
    let
      n : Nat := length xs;
    in if
      (n <= 1)
      xs
      (case split (div n 2) xs
        | l1, l2 := merge' (sort l1) (sort l2));

terminating
uniq : List Nat → List Nat
  | nil := nil
  | (x :: nil) := x :: nil
  | (x :: xs@(x' :: _)) :=
    if (x == x') (uniq xs) (x :: uniq xs);

gen : List Nat → Nat → (Nat → Nat) → List Nat
  | acc zero f := acc
  | acc (suc n) f := gen (f (suc n) :: acc) n f;

gen2 : List (List Nat) → Nat → Nat → List (List Nat)
  | acc m zero := acc
  | acc m (suc n) :=
    gen2 (gen nil m ((+) (suc n)) :: acc) m n;

printListNatLn : List Nat → IO
  | nil := printStringLn "nil"
  | (x :: xs) :=
    printNat x >> printString " :: " >> printListNatLn xs;

main : IO :=
  printListNatLn
      (take 10 (uniq (sort (flatten (gen2 nil 6 40)))))
    >> printListNatLn
      (take 10 (uniq (sort (flatten (gen2 nil 9 80)))))
    >> printListNatLn
      (take 10 (uniq (sort (flatten (gen2 nil 6 80)))));

