-- typed match

type List {
  cons : Π A : Type, A -> List A -> List A;
  nil : Π A : Type, List A;
};

def lgen : int → List int := \(n : int)
    if n = 0 then nil int else cons int n (lgen (n - 1));

def sum2 : List int → List int := \(x : List int) {
  match x : List int with : List int {
    cons _ x y@(cons _ z _) := cons int (x + z) (sum2 y);
    _ := x
  }
};

def sum : List int → int := \(x : List int) {
  match x : List int with : int {
    cons _ x y := x + sum y;
    _ := 0
  }
};

type Tree {
  leaf : Π A : Type, A -> Tree A;
  node : Π A : Type, Tree A -> Tree A -> Tree A;
};

def gen : int → Tree int := \(n : int)
    if n <= 0 then leaf int 1 else node int (gen (n - 2)) (gen (n - 1));

def g : Π A : Type, Tree A → Tree A := \(A : Type) \(t : Tree A) {
  match t : Tree A with : Tree A {
    leaf (A : Type) (x : A) := t;
    node _ (node _ _ _) r := r;
    node (A' : Type) (l : Tree A) (r : Tree A') := node A' r l;
  }
};

def f : Tree int → int := \(t : Tree int) match t : Tree int with : int {
  leaf _ (x : int) := x;
  node _ (l : Tree int) r :=
    match (g int l : Tree int), (g int r : Tree int) with : int {
      leaf _ _, leaf _ _ := 0 - 6;
      node (A : Type) (l : Tree A) (r : Tree int), leaf _ _ := ((f l + f r) * 2) % 20000;
      node (A : Type) (l1 : Tree A) (r1 : Tree A), node (B : Type) (l2 : Tree A) (r2 : Tree B) := ((f l1 + f r1) * (f l2 + f r2)) % 20000;
      _, node _ l r := ((f l + f r) * (0 - 3)) % 20000;
    }
};

def writeLn := \x write x >> write "\n";

writeLn (sum (sum2 (lgen 5))) >>
writeLn (f (gen 10)) >>
writeLn (f (gen 15)) >>
writeLn (f (gen 16)) >>
writeLn (f (gen 17)) >>
writeLn (f (gen 18)) >>
writeLn (f (gen 20))
