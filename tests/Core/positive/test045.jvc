-- type application and abstraction

type list : Π A : Type, Type {
  cons : Π A : Type, A → list A → list A;
  nil : Π A : Type, list A;
};

def id : Π A : Type, A → A := λ(A : Type) λ(x : A) x;

def hd : Π A : Type, list A → A := λ(A : Type) λl case l of { cons _ x _ := x };

def tl : Π A : Type, list A → list A := λ(A : Type) λl case l of { cons _ _ y := y };

def f := λ(A : Type) λ(x : A) λ(B : Type) λ(y : B) x + y;

def g := λ(A : Type) λ(xs : list A) λ(B : Type) λ(ys : list B) case xs of {
  cons A' x _ := case ys of {
    cons B' y _ := f A' x B' y;
    nil _ := x;
  };
  nil _ := 0;
};

def main := g int (cons int 2 (nil int)) int (cons int 3 (nil int)) * f int 1 int (hd int (tl int (id (list int) (cons int 1 (cons int 2 (nil int))))));

main
